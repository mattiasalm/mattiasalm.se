(function () {
  'use strict';

  var config = {
      general: {
          keyboardNavigationClassName: 'keyboard-nav',
      },
      content: {
          fileNotFoundPath: '/404',
          folder: 'content',
          navContentPath: '/nav',
          slashFallbackPath: '/index',
      },
      loading: {
          pageLoadClassName: 'fade',
          pageLoadDuration: 320,
          splashLoadClassName: 'splash-loading',
          splashLoadDuration: 4000,
      },
      links: {
          activeClass: 'active-link',
      },
      selectors: {
          body: 'body',
          content: '#content',
          nav: '#nav',
      }
  };

  var _elements = {};
  var _setElement = function (name, selector) {
      var elementRef = document.querySelector(selector);
      return !!elementRef ? (_elements[name] = elementRef) : null;
  };
  var getElementReference = {
      get bodyElem() {
          return _elements.bodyElem || _setElement('bodyElem', config.selectors.body);
      },
      get navElem() {
          return _elements.navElem || _setElement('navElem', config.selectors.nav);
      },
      get contentElem() {
          return _elements.contentElem || _setElement('contentElem', config.selectors.content);
      },
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  function __awaiter(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }

  //
  // Remove leading slash in string
  var stripLeadingSlash = function (str) { return str.replace(/^\/+/i, ''); };
  var wait = function (ms) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
      return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];
  }); }); };
  //
  // Check if url is considered to be a relative path
  var isRelativeUrl = function (url) {
      return url.indexOf('://') < 1 && url.indexOf('//') !== 0;
  };
  //
  // Check if is running on a Mac
  var isMac = function () { return window.navigator.appVersion.includes('Mac'); };
  //
  // Create full URL from path and append content folder and extension
  var createContentUrlFromPath = function (path) {
      var newPath = stripLeadingSlash(path);
      if (newPath === '') {
          newPath = config.content.slashFallbackPath;
      }
      return config.content.folder + "/" + newPath + ".html";
  };
  //
  // Add class on all links that match current path
  // and remove class on the others
  var setActiveLinks = function (parent, currentPath) {
      if (!(parent instanceof Element)) {
          return;
      }
      var linkElements = parent.querySelectorAll('a');
      var links = __spreadArrays(Array.from(linkElements));
      // Set active
      links
          .filter(function (link) {
          return !!link.getAttribute('href') &&
              stripLeadingSlash(link.getAttribute('href') || '') ===
                  stripLeadingSlash(currentPath);
      })
          .forEach(function (link) {
          link.classList.add(config.links.activeClass);
      });
      // Set inactive
      links
          .filter(function (link) {
          return !!link.getAttribute('href') &&
              stripLeadingSlash(link.getAttribute('href') || '') !==
                  stripLeadingSlash(currentPath);
      })
          .forEach(function (link) {
          link.classList.remove(config.links.activeClass);
      });
  };
  var hideSplashLoading = function (loadingTime) {
      if (loadingTime > config.loading.splashLoadDuration) {
          if (!!getElementReference.bodyElem) {
              getElementReference.bodyElem.classList.remove(config.loading.splashLoadClassName);
          }
      }
      else {
          setTimeout(function () {
              if (!!getElementReference.bodyElem) {
                  getElementReference.bodyElem.classList.remove(config.loading.splashLoadClassName);
              }
          }, config.loading.splashLoadDuration - loadingTime);
      }
  };
  //
  // Async fetch content from URL and return as text
  var getHtmlFromUrl = function (url) { return __awaiter(void 0, void 0, void 0, function () {
      var response;
      return __generator(this, function (_a) {
          switch (_a.label) {
              case 0: return [4 /*yield*/, fetch(url)];
              case 1:
                  response = _a.sent();
                  if (response.status >= 400 && response.status < 600) {
                      throw new Error('File not found');
                  }
                  return [4 /*yield*/, response.text()];
              case 2: return [2 /*return*/, _a.sent()];
          }
      });
  }); };
  var utils = {
      stripLeadingSlash: stripLeadingSlash,
      wait: wait,
      isRelativeUrl: isRelativeUrl,
      isMac: isMac,
      createContentUrlFromPath: createContentUrlFromPath,
      setActiveLinks: setActiveLinks,
      hideSplashLoading: hideSplashLoading,
      getHtmlFromUrl: getHtmlFromUrl,
  };

  //
  // Remove all child nodes in parent element
  var removeChildren = function (parent) {
      while (parent instanceof Element && parent.firstChild) {
          parent.firstChild.remove();
      }
  };
  //
  // Add child node to parent element
  var addChild = function (parent, child) {
      if (parent instanceof Element && !!child) {
          parent.appendChild(child);
      }
  };
  //
  // Create element nodes from HTML text string
  var createNodesFromHtmlString = function (html) {
      var template = document.createElement('template');
      template.innerHTML = html;
      return __spreadArrays(Array.from(template.content.childNodes));
  };
  var replaceNodesFromHtmlString = function (parent, htmlString) {
      removeChildren(parent);
      createNodesFromHtmlString(htmlString).forEach(function (child) {
          return addChild(parent, child);
      });
  };
  var nodes = {
      removeChildren: removeChildren,
      addChild: addChild,
      createNodesFromHtmlString: createNodesFromHtmlString,
      replaceNodesFromHtmlString: replaceNodesFromHtmlString,
  };

  var currentPath = function () { return window.location.pathname; };
  var setNewPath = function (newPath) {
      return currentPath() === newPath
          ? undefined
          : history.pushState('', newPath, newPath);
  };
  var closeMenu = function () {
      if (!!getElementReference.navElem) {
          var inputElem = getElementReference.navElem.querySelector('input');
          if (!!inputElem && inputElem.checked) {
              inputElem.checked = false;
          }
      }
  };
  var updateActiveLinksInMenu = function () {
      if (!!getElementReference.navElem) {
          utils.setActiveLinks(getElementReference.navElem, currentPath());
      }
  };
  var navigation = {
      currentPath: currentPath,
      setNewPath: setNewPath,
      closeMenu: closeMenu,
      updateActiveLinksInMenu: updateActiveLinksInMenu,
  };

  //
  // Fetch new content based on path and mount it in the DOM #content container
  var content = function (path) { return __awaiter(void 0, void 0, void 0, function () {
      var url, html;
      return __generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  url = utils.createContentUrlFromPath(path);
                  return [4 /*yield*/, utils.getHtmlFromUrl(url).catch(function (err) {
                          // CHECK STATUS HERE
                          if (path !== config.content.fileNotFoundPath) {
                              return content(config.content.fileNotFoundPath);
                          }
                          throw new Error(err);
                      })];
              case 1:
                  html = _a.sent();
                  if (!(!!html && getElementReference.contentElem)) return [3 /*break*/, 4];
                  if (!( getElementReference.bodyElem)) return [3 /*break*/, 4];
                  getElementReference.bodyElem.classList.add(config.loading.pageLoadClassName);
                  return [4 /*yield*/, utils.wait(config.loading.pageLoadDuration)];
              case 2:
                  _a.sent();
                  _a.label = 3;
              case 3:
                  nodes.replaceNodesFromHtmlString(getElementReference.contentElem, html);
                  navigation.setNewPath(path);
                  getElementReference.bodyElem.classList.remove(config.loading.pageLoadClassName);
                  _a.label = 4;
              case 4: return [2 /*return*/];
          }
      });
  }); };
  //
  // Fetch nav content and mount it in the DOM #nav container
  var nav = function () { return __awaiter(void 0, void 0, void 0, function () {
      var url, html;
      return __generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  url = utils.createContentUrlFromPath(config.content.navContentPath);
                  return [4 /*yield*/, utils.getHtmlFromUrl(url).catch(function (err) {
                          throw new Error(err);
                      })];
              case 1:
                  html = _a.sent();
                  if (!!html && !!getElementReference.navElem) {
                      nodes.replaceNodesFromHtmlString(getElementReference.navElem, html);
                  }
                  return [2 /*return*/];
          }
      });
  }); };
  var load = {
      content: content,
      nav: nav,
  };

  //
  // On window load event (when all linked resources has been loaded)
  // read path from window URL and load content corresponding to that
  // also load nav content
  var onLoad = function () {
      var timeStart = performance.now();
      Promise.all([load.content(navigation.currentPath()), load.nav()]).then(function () {
          navigation.updateActiveLinksInMenu();
          utils.hideSplashLoading(performance.now() - timeStart);
      });
  };
  //
  // Catch all click events that has and anchor as target
  // and prevent all relative link paths from reloading the page.
  // Load the new content in the #content container instead
  var onClick = function (event) {
      // Turn of keyboard navigation highlight
      if (event.clientX && event.clientY && getElementReference.bodyElem instanceof Element) {
          getElementReference.bodyElem.classList.remove(config.general.keyboardNavigationClassName);
      }
      if (event.target instanceof Element) {
          var clickedElement = event.target;
          // Dont do anything if the clicked target is not an A-tag
          if (clickedElement.tagName.toLowerCase() !== 'a') {
              return;
          }
          // Check if the path is relative to this site
          var path = clickedElement.getAttribute('href');
          if (!!path && utils.isRelativeUrl(path)) {
              // Check if the link target is intended to be opened in a new tab or window.
              var newTab = (utils.isMac() && event.metaKey) || (!utils.isMac() && event.ctrlKey);
              var newWindow = event.shiftKey;
              if (newTab || newWindow) {
                  return;
              }
              // Load new content based on relative link path
              event.preventDefault();
              navigation.closeMenu();
              load.content(path).then(function () { return navigation.updateActiveLinksInMenu(); });
          }
      }
  };
  //
  // When back button is clicked in browser update the content
  // corresponding to the path
  var onPopState = function (event) {
      event.preventDefault();
      navigation.closeMenu();
      load
          .content(navigation.currentPath())
          .then(function () { return navigation.updateActiveLinksInMenu(); });
  };
  var onKeyUp = function (event) {
      // If using TAB key to navigate; enable keyboard navigation highlight by adding classname to body
      if (event.which === 9 && !!getElementReference.bodyElem) {
          getElementReference.bodyElem.classList.add(config.general.keyboardNavigationClassName);
      }
      // Close the menu by pressing ESC if it is open
      if (event.which === 27) {
          navigation.closeMenu();
      }
  };
  var hooks = {
      onLoad: onLoad,
      onClick: onClick,
      onPopState: onPopState,
      onKeyUp: onKeyUp,
  };

  window.onload = hooks.onLoad;
  window.onclick = hooks.onClick;
  window.onpopstate = hooks.onPopState;
  window.onkeyup = hooks.onKeyUp;

}());
