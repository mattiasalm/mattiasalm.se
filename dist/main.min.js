(function () {
  'use strict';

  const _elements = {};
  const _setElement = (name, selector) =>
    (_elements[name] = document.querySelector(selector));

  var elements = {
    get body() {
      return _elements.body || _setElement('body', 'body');
    },

    get nav() {
      return _elements.nav || _setElement('nav', '#nav');
    },

    get contentNode() {
      return _elements.contentNode || _setElement('contentNode', '#content');
    },
  };

  var config = {
    content: {
      folder: 'content',
    },
  };

  //
  // Remove leading slash in string
  const stripLeadingSlash = str => str.replace(/^\/+/i, '');

  var utils = {
    async wait(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    },

    //
    // Check if url is considered to be a relative path
    isRelativeUrl: url => url.indexOf('://') < 1 && url.indexOf('//') !== 0,

    //
    // Check if is running on a Mac
    isMac: () => window.navigator.appVersion.includes('Mac'),

    //
    // Create full URL from path and append content folder and extension
    createUrlFromPath: path => {
      let newPath = stripLeadingSlash(path);
      if (newPath === '') {
        newPath = 'index';
      }
      return `${config.content.folder}/${newPath}.html`;
    },

    stripLeadingSlash
  };

  var fetching = {
    //
    // Async fetch content from URL and return as text
    async getHtmlFromUrl(url) {
      const response = await fetch(url);
      if (response.status >= 400 && response.status < 600) {
        throw new Error('File not found');
      }
      return await response.text();
    },
  };

  var modification = {
    //
    // Add class 'active-link' on all links that match current path
    // and remove class on the others
    setActiveLinks: (links, currentPath) => {
      // Set active
      links
        .filter(
          link =>
            utils.stripLeadingSlash(link.getAttribute('href')) ===
            utils.stripLeadingSlash(currentPath)
        )
        .forEach(link => {
          link.classList.add('active-link');
        });

      // Set inactive
      links
        .filter(
          link =>
            utils.stripLeadingSlash(link.getAttribute('href')) !==
            utils.stripLeadingSlash(currentPath)
        )
        .forEach(link => {
          link.classList.remove('active-link');
        });
    },
  };

  var route = {
    get path() {
      return window.location.pathname;
    },

    set path(newPath) {
      if (window.location.pathname === newPath) {
        return;
      }
      history.pushState('', newPath, newPath);
    },
  };

  //
  // Remove all child nodes in parent element
  const removeChildren = parent => {
    while (parent.firstChild) {
      parent.firstChild.remove();
    }
  };

  //
  // Add child node to parent element
  const addChild = (parent, child) => parent.appendChild(child);

  //
  // Create element nodes from HTML text string
  const createNodesFromHtml = html => {
    const template = document.createElement('template');
    template.innerHTML = html;
    return template.content.childNodes;
  };

  var nodes = {
    removeChildren,
    addChild,
    createNodesFromHtml,

    replaceNodesFromHtml: (parent, html) => {
      // console.log(elements.contentNode.childNodes)
      // const config = { attributes: true, childList: true, subtree: true };
      // const observer = new MutationObserver((mutationList, observer) => {
      //   console.log(elements.contentNode.childNodes)
      //   console.log(Array.from(mutationList));
      // })
      // observer.observe(elements.contentNode, config);
      removeChildren(parent);
      createNodesFromHtml(html)
        .forEach(child => addChild(parent, child));
    },
  };

  var load = {
    //
    // Fetch new content based on path and mount it in the DOM #content container
    async content(path) {
      const url = utils.createUrlFromPath(path);
      const html = await fetching.getHtmlFromUrl(url).catch(err => {
        // CHECK STATUS HERE
        if (path !== '/404') {
          return load.content('/404');
        }
        throw new Error(err);
      });

      if (!!html) {
        elements.body.classList.add('fade');
        // bodyAttribute.add('fade');
        await utils.wait(320);
        nodes.replaceNodesFromHtml(elements.contentNode, html);
        route.path = path;
        elements.body.classList.remove('fade');
        // bodyAttribute.remove('fade');
      }
    },

    //
    // Fetch nav content and mount it in the DOM #nav container
    async nav() {
      const url = utils.createUrlFromPath('/nav');
      const html = await fetching.getHtmlFromUrl(url).catch(err => {
        throw new Error(err);
      });

      if (!!html) {
        nodes.replaceNodesFromHtml(elements.nav, html);
      }
    },
  };

  var hooks = {
    //
    // On window load event (when all linked resources has been loaded)
    // read path from window URL and load content corresponding to that
    // also load nav content
    onLoad: () => {
      const timeStart = performance.now();
      Promise.all([load.content(route.path), load.nav()]).then(() => {
        modification.setActiveLinks([...elements.nav.querySelectorAll('a')], route.path);
        const timing = performance.now() - timeStart;
        const splashMinDuration = 4000;
        if (timing > splashMinDuration) {
          elements.body.classList.remove('splash-loading');
        } else {
          setTimeout(() => {
            elements.body.classList.remove('splash-loading');
          }, splashMinDuration - timing);
        }
      });
    },

    //
    // Catch all click events that has and anchor as target
    // and prevent all relative link paths from reloading the page.
    // Load the new content in the #content container instead
    onclick: event => {
      if (event.clientX && event.clientY) {
        elements.body.classList.remove('keyboard-nav');
      }

      if (!event.target.matches('a')) {
        return;
      }

      const path = event.target.getAttribute('href');
      if (path && utils.isRelativeUrl(path)) {
        const newTab =
          (utils.isMac() && event.metaKey) || (!utils.isMac() && event.ctrlKey);
        const newWindow = event.shiftKey;

        if (newTab || newWindow) {
          return;
        }

        event.preventDefault();
        elements.nav.querySelector('input').checked = false;
        load.content(path).then(() => {
          modification.setActiveLinks([...elements.nav.querySelectorAll('a')], route.path);
        });
      }
    },

    //
    // When back button is clicked in browser update the content
    // corresponding to the path
    onpopstate: event => {
      event.preventDefault();
      load.content(route.path).then(() => {
        modification.setActiveLinks([...elements.nav.querySelectorAll('a')], route.path);
      });
    },

    onkeyup: event => {
      if (event.which === 9) {
        elements.body.classList.add('keyboard-nav');
      }

      if (event.which === 27 && elements.nav.querySelector('input').checked) {
        elements.nav.querySelector('input').checked = false;
      }
    },
  };

  window.onload = hooks.onLoad;
  window.onclick = hooks.onclick;
  window.onpopstate = hooks.onpopstate;
  window.onkeyup = hooks.onkeyup;

}());
