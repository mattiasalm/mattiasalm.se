(function () {
  'use strict';

  const _elements = {};
  const _setElement = (name, selector) =>
    (_elements[name] = document.querySelector(selector));

  var elements = {
    get bodyElem() {
      return _elements.bodyElem || _setElement('bodyElem', 'body');
    },

    get navElem() {
      return _elements.navElem || _setElement('navElem', '#nav');
    },

    get contentElem() {
      return _elements.contentElem || _setElement('contentElem', '#content');
    },
  };

  var config = {
    content: {
      fileNotFoundPath: '/404',
      folder: 'content',
      loadingAddClass: true,
      loadingClassName: 'fade',
      loadingClassDelay: 320,
      navContentPath: '/nav',
      slashFallbackPath: '/index', // the path to use as fallback for links with path '/'
    },
    links: {
      activeClass: 'active-link'
    }
  };

  //
  // Remove leading slash in string
  const stripLeadingSlash = str => str.replace(/^\/+/i, '');

  const wait = async ms => new Promise(resolve => setTimeout(resolve, ms));

  //
  // Check if url is considered to be a relative path
  const isRelativeUrl = url => url.indexOf('://') < 1 && url.indexOf('//') !== 0;

  //
  // Check if is running on a Mac
  const isMac = () => window.navigator.appVersion.includes('Mac');

  //
  // Create full URL from path and append content folder and extension
  const createContentUrlFromPath = path => {
    let newPath = stripLeadingSlash(path);
    if (newPath === '') {
      newPath = config.content.slashFallbackPath;
    }
    return `${config.content.folder}/${newPath}.html`;
  };

  var utils = {
    stripLeadingSlash,
    wait,
    isRelativeUrl,
    isMac,
    createContentUrlFromPath,
  };

  //
  // Add class on all links that match current path
  // and remove class on the others
  const setActiveLinks = (links, currentPath) => {
    // Set active
    links
      .filter(
        link =>
          utils.stripLeadingSlash(link.getAttribute('href')) ===
          utils.stripLeadingSlash(currentPath)
      )
      .forEach(link => {
        link.classList.add(config.links.activeClass);
      });

    // Set inactive
    links
      .filter(
        link =>
          utils.stripLeadingSlash(link.getAttribute('href')) !==
          utils.stripLeadingSlash(currentPath)
      )
      .forEach(link => {
        link.classList.remove(config.links.activeClass);
      });
  };

  var modification = {
    setActiveLinks,
  };

  const currentPath = () => window.location.pathname;

  const setNewPath = newPath => currentPath() === newPath
    ? undefined
    : history.pushState('', newPath, newPath);

  var route = {
    currentPath,
    setNewPath,
  };

  //
  // Async fetch content from URL and return as text
  const getHtmlFromUrl = async url => {
    const response = await fetch(url);
    if (response.status >= 400 && response.status < 600) {
      throw new Error('File not found');
    }
    return await response.text();
  };

  var fetching = {
    getHtmlFromUrl,
  };

  //
  // Remove all child nodes in parent element
  const removeChildren = parent => {
    while (parent.firstChild) {
      parent.firstChild.remove();
    }
  };

  //
  // Add child node to parent element
  const addChild = (parent, child) => parent.appendChild(child);

  //
  // Create element nodes from HTML text string
  const createNodesFromHtml = html => {
    const template = document.createElement('template');
    template.innerHTML = html;
    return template.content.childNodes;
  };

  const replaceNodesFromHtml = (parent, html) => {
    // console.log(elements.contentElem.childNodes)
    // const config = { attributes: true, childList: true, subtree: true };
    // const observer = new MutationObserver((mutationList, observer) => {
    //   console.log(elements.contentElem.childNodes)
    //   console.log(Array.from(mutationList));
    // })
    // observer.observe(elements.contentElem, config);
    removeChildren(parent);
    createNodesFromHtml(html)
      .forEach(child => addChild(parent, child));
  };

  var nodes = {
    removeChildren,
    addChild,
    createNodesFromHtml,
    replaceNodesFromHtml,
  };

  //
  // Fetch new content based on path and mount it in the DOM #content container
  const content = async path => {
    const url = utils.createContentUrlFromPath(path);
    const html = await fetching.getHtmlFromUrl(url).catch(err => {
      // CHECK STATUS HERE
      if (path !== config.content.fileNotFoundPath) {
        return content(config.content.fileNotFoundPath);
      }
      throw new Error(err);
    });

    if (!!html) {
      {
        elements.bodyElem.classList.add(config.content.loadingClassName);
        {
          await utils.wait(config.content.loadingClassDelay);
        }
      }
      nodes.replaceNodesFromHtml(elements.contentElem, html);
      route.setNewPath(path);
      {
        elements.bodyElem.classList.remove(config.content.loadingClassName);
      }
    }
  };

  //
  // Fetch nav content and mount it in the DOM #nav container
  const nav = async () => {
    const url = utils.createContentUrlFromPath(config.content.navContentPath);
    const html = await fetching.getHtmlFromUrl(url).catch(err => {
      throw new Error(err);
    });

    if (!!html) {
      nodes.replaceNodesFromHtml(elements.navElem, html);
    }
  };

  var load = {
    content,
    nav,
  };

  //
  // On window load event (when all linked resources has been loaded)
  // read path from window URL and load content corresponding to that
  // also load nav content
  const onLoad = () => {
    const timeStart = performance.now();
    Promise.all([load.content(route.currentPath()), load.nav()]).then(() => {
      modification.setActiveLinks([...elements.navElem.querySelectorAll('a')], route.currentPath());
      const timing = performance.now() - timeStart;

      const splashMinDuration = 4000;
      if (timing > splashMinDuration) {
        elements.bodyElem.classList.remove('splash-loading');
      } else {
        setTimeout(() => {
          elements.bodyElem.classList.remove('splash-loading');
        }, splashMinDuration - timing);
      }
    });
  };

  //
  // Catch all click events that has and anchor as target
  // and prevent all relative link paths from reloading the page.
  // Load the new content in the #content container instead
  const onClick = event => {
    if (event.clientX && event.clientY) {
      elements.bodyElem.classList.remove('keyboard-nav');
    }

    if (!event.target.matches('a')) {
      return;
    }

    const path = event.target.getAttribute('href');
    if (path && utils.isRelativeUrl(path)) {
      const newTab =
        (utils.isMac() && event.metaKey) || (!utils.isMac() && event.ctrlKey);
      const newWindow = event.shiftKey;

      if (newTab || newWindow) {
        return;
      }

      event.preventDefault();
      elements.navElem.querySelector('input').checked = false;
      load.content(path).then(() => {
        modification.setActiveLinks([...elements.navElem.querySelectorAll('a')], route.currentPath());
      });
    }
  };

  //
  // When back button is clicked in browser update the content
  // corresponding to the path
  const onPopState = event => {
    event.preventDefault();
    load.content(route.currentPath()).then(() => {
      modification.setActiveLinks([...elements.navElem.querySelectorAll('a')], route.currentPath());
    });
  };

  const onKeyUp = event => {
    if (event.which === 9) {
      elements.bodyElem.classList.add('keyboard-nav');
    }

    if (event.which === 27 && elements.navElem.querySelector('input').checked) {
      elements.navElem.querySelector('input').checked = false;
    }
  };

  var hooks = {
    onLoad,
    onClick,
    onPopState,
    onKeyUp
  };

  window.onload = hooks.onLoad;
  window.onclick = hooks.onClick;
  window.onpopstate = hooks.onPopState;
  window.onkeyup = hooks.onKeyUp;

}());
